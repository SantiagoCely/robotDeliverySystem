import { FormControl, ValidatorFn, AsyncValidatorFn, AbstractControlOptions } from "@angular/forms";
import { DataSanitizer } from '../core/validator.interface';
export declare class RxFormControl extends FormControl {
    private entityObject;
    private baseObject;
    private _sanitizers;
    private _language;
    private keyName;
    private _errorMessage;
    private _errorMessages;
    private _disableProvider;
    private _columns;
    private _childColumns;
    private _parentColumns;
    private _refDisableControls;
    private _refMessageControls;
    private _refClassNameControls;
    private _errorMessageBindingStrategy;
    private _messageExpression;
    private _classNameExpression;
    private _isPassedExpression;
    private _controlProp;
    private _classNameControlProp;
    private _baseValue;
    private _isModified;
    private _errors;
    private _dirty;
    private _validators;
    private _asyncValidators;
    backEndErrors: {
        [key: string]: string;
    };
    updateOnElementClass: boolean | Function;
    preHook: Function;
    postHook: Function;
    get errorMessages(): string[];
    get errorMessage(): string;
    constructor(formState: any, validator: ValidatorFn | AbstractControlOptions | ValidatorFn[] | null, asyncValidator: AsyncValidatorFn | AsyncValidatorFn[] | null, entityObject: {
        [key: string]: any;
    }, baseObject: {
        [key: string]: any;
    }, controlName: string, _sanitizers: DataSanitizer[]);
    private defineErrorsProperty;
    private getFormState;
    get isModified(): boolean;
    getValidators(): ValidatorFn[];
    getAsyncValidators(): AsyncValidatorFn[];
    private getValidatorSource;
    setValidators(newValidator: ValidatorFn | ValidatorFn[] | null): void;
    setAsyncValidators(newValidator: AsyncValidatorFn | AsyncValidatorFn[] | null): void;
    setValue(value: any, options?: {
        dirty?: boolean;
        updateChanged?: boolean;
        onlySelf?: boolean;
        emitEvent?: boolean;
        isThroughDynamic?: boolean;
    }): void;
    getControlValue(): any;
    bindError(): void;
    bindClassName(): void;
    setBackEndErrors(error: {
        [key: string]: string;
    }): void;
    clearBackEndErrors(errors?: {
        [key: string]: any;
    }): void;
    markAsTouched(opts?: {
        onlySelf?: boolean;
    }): void;
    markAsUntouched(opts?: {
        onlySelf?: boolean;
    }): void;
    markAsDirty(opts?: {
        onlySelf?: boolean;
    }): void;
    markAsPristine(opts?: {
        onlySelf?: boolean;
    }): void;
    markAsPending(opts?: {
        onlySelf?: boolean;
        emitEvent?: boolean;
    }): void;
    runControlPropChangeExpression(propNames: string[]): void;
    refresh(): void;
    reset(value?: any): void;
    commit(): void;
    private callPatch;
    private checkErrorMessageStrategy;
    private executeExpressions;
    private getMessageExpression;
    private getSanitizedValue;
    private bindConditionalControls;
    private setControlErrorMessages;
    private getLanguage;
    private getErrorMessage;
    private processExpression;
    private executeExpression;
    private getValue;
}
